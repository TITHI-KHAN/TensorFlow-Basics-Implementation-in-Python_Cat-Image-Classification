# -*- coding: utf-8 -*-
"""TensorFlow-Basics-Implementation-in-Python_Cat-Image-Classification.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GEtn-5H0DSr-eCFzB8MhDnmVDLsI8n9b
"""

import tensorflow as tf

x = tf.constant(5)  # Scalar
y = tf.constant([1, 2, 3])  # Vector
z = tf.constant([[1, 2], [3, 4]])  # Matrix

a = tf.constant([[1, 2], [3, 4]])
b = tf.constant([[5, 6], [7, 8]])
result = tf.matmul(a, b)

weight = tf.Variable(tf.random.normal([5, 10]))

"""**Model Create**"""

from keras.models import Sequential
from keras.layers import Conv2D, MaxPooling2D, Flatten, Dense
from keras.optimizers import Adam
from keras.preprocessing.image import img_to_array, load_img
from keras.preprocessing.image import ImageDataGenerator
from sklearn.model_selection import train_test_split
import numpy as np
from PIL import Image
import matplotlib.pyplot as plt


img_path = '/content/Cats.jpg'  # Replace with the path to your image
img = load_img(img_path, target_size=(224, 224))  # Resize image
img_array = img_to_array(img)  # Convert image to array
img_array = np.expand_dims(img_array, axis=0)  # Add batch dimension
img_array /= 255.0  # Scale pixel values


model = Sequential([
    Conv2D(32, (3, 3), activation='relu', input_shape=(224, 224, 3)),
    MaxPooling2D(2, 2),
    Conv2D(64, (3, 3), activation='relu'),
    MaxPooling2D(2, 2),
    Flatten(),
    Dense(64, activation='relu'),
    Dense(1, activation='sigmoid')
])

# Compile the model
model.compile(optimizer=Adam(lr=0.001), loss='binary_crossentropy', metrics=['accuracy'])

# Since we don't have a dataset, let's create dummy data
# For the purpose of demonstration, we'll use the same image as both the feature and the label
X = np.repeat(img_array, 100, axis=0)  # Creating 100 duplicate images
y = np.zeros((100, 1))  # Assuming all images are class '0' for cats

# Split the data into training and validation sets
X_train, X_val, y_train, y_val = train_test_split(X, y, test_size=0.2, random_state=42)

# Continue with data generators
train_datagen = ImageDataGenerator(
    rotation_range=40,
    width_shift_range=0.2,
    height_shift_range=0.2,
    shear_range=0.2,
    zoom_range=0.2,
    horizontal_flip=True,
    fill_mode='nearest')

val_datagen = ImageDataGenerator()  # Validation data should not be augmented
# The .flow() command below generates batches of randomly transformed images
# and normalizes the pixel values
train_generator = train_datagen.flow(X_train, y_train, batch_size=20)
val_generator = val_datagen.flow(X_val, y_val, batch_size=20)

# Train the model
# Note: We are using .fit() here for simplicity, but .fit_generator() is recommended for actual training
history = model.fit(
    train_generator,
    steps_per_epoch=100,  # Number of images in the training set
    epochs=10,
    validation_data=val_generator,
    validation_steps=50  # Number of images in the validation set
)

prediction = model.predict(img_array)
print("Prediction (0 for cat, 1 for non-cat):", prediction[0][0])
model.save('cat_classifier_model.h5')

plt.imshow(np.squeeze(img))  # Remove batch dimension and show image
plt.axis('off')  # Hide the axis

# Get the prediction
prediction = model.predict(img_array)

# Add the prediction as the title of the plot
plt.title(f'Prediction (0 for cat, 1 for non-cat): {prediction[0][0]:.4f}')

# Show the plot
plt.show()

"""> **Confidence Value**

The confidence value associated with a prediction represents the model's level of certainty or trust in its prediction. It indicates how far the prediction value is from the decision boundary, which is typically set at 0.5 for binary classification tasks.

In binary classification scenarios like classifying images as "cat" or "non-cat" (which includes images of dogs), a prediction value close to 1 suggests high confidence in the prediction of "cat," while a prediction value close to 0 indicates high confidence in the prediction of "non-cat" (which includes images of dogs).

**Classifying dog as cat**
"""

import numpy as np
from keras.models import load_model
from keras.preprocessing.image import img_to_array, load_img
import matplotlib.pyplot as plt

# Load the trained model
model = load_model('cat_classifier_model.h5')

# Path to the random image you want to test
random_img_path = '/content/dog.jpg'  # Replace with the path to the random image

# Preprocess the image
img = load_img(random_img_path, target_size=(224, 224))  # Resize image
img_array = img_to_array(img)  # Convert image to array
img_array = np.expand_dims(img_array, axis=0)  # Add batch dimension
img_array /= 255.0  # Scale pixel values

# Make a prediction
prediction = model.predict(img_array)
prediction_value = prediction[0][0]
confidence = 1 - prediction_value if prediction_value < 0.5 else prediction_value
prediction_label = 'Cat' if prediction_value < 0.5 else 'Non-cat'

# Display the prediction value, label, and confidence
print("Prediction Value:", prediction_value)
print("Prediction Label:", prediction_label)
print("Confidence:", confidence)

# Visualize the image and prediction
plt.imshow(img)  # Show image
plt.axis('off')  # Hide the axis
plt.title(f'Prediction: {prediction_label} (Confidence: {confidence:.4f})')  # Show prediction
plt.show()

"""**Classifying horse as cat**"""

import numpy as np
from keras.models import load_model
from keras.preprocessing.image import img_to_array, load_img
import matplotlib.pyplot as plt

# Load the trained model
model_path = '/content/cat_classifier_model.h5'  # Replace with the path to your model file
model = load_model(model_path)

# Path to the random image you want to test
random_img_path = '/content/Horse.jpg'  # Replace with the path to your test image

# Preprocess the image
img = load_img(random_img_path, target_size=(224, 224))  # Resize image
img_array = img_to_array(img)  # Convert image to array
img_array = np.expand_dims(img_array, axis=0)  # Add batch dimension
img_array /= 255.0  # Scale pixel values

# Make a prediction
prediction = model.predict(img_array)
prediction_label = 'Cat' if prediction[0][0] < 0.5 else 'Non-cat'

# Display the prediction value, label, and confidence
print("Prediction Value:", prediction_value)
print("Prediction Label:", prediction_label)
print("Confidence:", confidence)

# Visualize the image and prediction
plt.imshow(img)  # Show image
plt.axis('off')  # Hide the axis
plt.title(f'Prediction: {prediction_label} ({prediction[0][0]:.4f})')  # Show prediction
plt.show()

"""**Classifying car as cat**"""

import json
import numpy as np
from keras.models import load_model
from keras.preprocessing.image import img_to_array, load_img
import matplotlib.pyplot as plt

# Load ImageNet classes
with open('/content/imagenet_class_index.json') as f:
    class_index = json.load(f)
    class_index = {int(key): value for key, value in class_index.items()}

# Load the trained model (make sure to replace this with the path to your actual model)
model = load_model('/content/cat_classifier_model.h5')

# Path to the random image you want to test
random_img_path = '/content/car.jpg'

# Preprocess the image
img = load_img(random_img_path, target_size=(224, 224))
img_array = img_to_array(img)
img_array = np.expand_dims(img_array, axis=0)
img_array /= 255.0

# Make a prediction
preds = model.predict(img_array)
predicted_class = np.argmax(preds, axis=1)
predicted_class_name = class_index[predicted_class[0]][1]

# Display the prediction value, label, and confidence
print("Prediction Value:", prediction_value)
print("Prediction Label:", prediction_label)
print("Confidence:", confidence)

# Visualize the image and prediction
plt.imshow(img)
plt.axis('off')
plt.title(f'Predicted: {predicted_class_name}')
plt.show()

# Visualize the image and prediction
plt.imshow(img)  # Show image
plt.axis('off')  # Hide the axis
plt.title(f'Prediction: {prediction_label} ({prediction[0][0]:.4f})')  # Show prediction
plt.show()

"""**ImageNet class index JSON file:**"""

import json

# Load the JSON file
with open('imagenet_class_index.json') as f:
    class_index = json.load(f)

# Access class information
class_id = '0'  # Example class ID
class_info = class_index[class_id]
imagenet_id, class_name = class_info

print(f'ImageNet ID: {imagenet_id}')
print(f'Class Name: {class_name}')

"""

>
**I will create a new updated model and upload it that can classify images as "cat" or "non-cat" properly regardless of the image.**"""